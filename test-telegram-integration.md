# Telegram Integration Test Plan

## Summary of Fixes Made

### Problem Identified
The original `profile.js` was generating **mock telegram keys** that were:
- Temporary (24-hour expiration)
- Not properly connected to the server-side system
- Using incorrect Firestore collections
- Not truly unique per user account

### Solutions Implemented

#### 1. **Fixed Profile.js Key Generation**
- **Before**: Client-side mock key generation with `TG-${userPart}-${timestamp}-${randomPart}`
- **After**: Server-side permanent key generation via `/api/user/register` endpoint
- **Result**: Every user gets a **truly unique, permanent key** generated by the server

#### 2. **Unified Firestore Collections**
- **Before**: Mixed use of `telegramKeys` and `telegram_keys` collections
- **After**: Standardized on server-side `telegram_keys` collection
- **Result**: Consistent data storage and lookup

#### 3. **Proper Authentication Flow**
- **Before**: Mock connection status updates
- **After**: Real server API calls with Firebase auth tokens
- **Result**: Secure, authenticated key management

#### 4. **Bot Integration Fixes**
- **Before**: Fallback to demo validation
- **After**: Strict server-side validation only
- **Result**: No mock connections, only real validated users

## Test Scenarios

### Test 1: New User Registration
```
1. User signs up on Kita-kita web app
2. Server automatically generates unique telegram key via `createUserWithTelegramKey()`
3. Key is stored in both:
   - `users/{userId}` document (with telegramKey field)
   - `telegram_keys/{key}` document (for bot lookup)
4. Profile page displays permanent key
```

### Test 2: Telegram Bot Connection
```
1. User opens Telegram bot (@kitakita_receipt_bot)
2. User sends `/connect TG-XXXXXX-XXXXXXX-XXXXXX`
3. Bot validates key via `/api/telegram/validate-key`
4. If valid, bot calls `/api/telegram/connect` 
5. Server marks key as used and updates user record
6. User profile shows "Connected" status
```

### Test 3: Key Regeneration
```
1. User clicks "Refresh Key" in profile
2. Profile.js calls `/api/user/{userId}/regenerate-telegram-key`
3. Server generates new key and invalidates old one
4. New key displayed in profile immediately
```

### Test 4: Connection Status Updates
```
1. Profile.js polls user data every 30 seconds
2. Checks `telegramKeyUsed` field in user document
3. Updates UI to show connection status
4. Shows telegram username when connected
```

## Verification Checklist

### ✅ Unique Key Generation
- [ ] Each user gets exactly one permanent telegram key
- [ ] Keys are generated server-side using secure random generation
- [ ] Keys follow format: `TG-{timestamp}-{random}` (uppercase)
- [ ] Keys are stored in `telegram_keys` collection with user mapping

### ✅ Firestore Auditing
- [ ] Every key creation logged in `telegram_keys/{key}` document
- [ ] User document updated with `telegramKey` field
- [ ] Connection events logged with timestamps
- [ ] Key usage tracked (`used: false/true`)

### ✅ Security
- [ ] Profile page requires Firebase authentication
- [ ] API endpoints validate user ID tokens
- [ ] Users can only access their own keys
- [ ] No fallback to demo/mock validation

### ✅ Bot Integration
- [ ] Bot validates keys via server API only
- [ ] Connection updates user record in real-time
- [ ] Profile page reflects connection status
- [ ] Key usage prevents reuse

## Database Schema

### users/{userId}
```json
{
  "email": "user@example.com",
  "telegramKey": "TG-ABC123DEF-XYZ789",
  "telegramKeyCreatedAt": "timestamp",
  "telegramKeyUsed": false,
  "telegramLinkedAt": "timestamp",
  "telegramUserId": "telegram_user_id",
  "telegramUsername": "telegram_username"
}
```

### telegram_keys/{key}
```json
{
  "userId": "firebase_user_id",
  "email": "user@example.com", 
  "createdAt": "timestamp",
  "used": false,
  "usedAt": "timestamp",
  "telegramUserId": "telegram_user_id"
}
```

## API Endpoints

### 1. **GET /api/user/{userId}/telegram-key**
- Returns user's permanent telegram key
- Requires authentication
- Used by profile page to load key

### 2. **POST /api/user/{userId}/regenerate-telegram-key**
- Generates new telegram key for user
- Invalidates old key
- Requires authentication

### 3. **POST /api/telegram/validate-key**
- Validates telegram key for bot
- Checks if key exists and is unused
- Used by bot during connection

### 4. **POST /api/telegram/connect**
- Marks key as used
- Updates user record with telegram info
- Called by bot after successful validation

### 5. **POST /api/telegram/verify-credentials**
- Verifies email + telegram key combination
- Used by bot for email-based connection flow

## Expected Behavior After Fixes

1. **Profile Page**: Shows permanent, unique telegram key for each user
2. **Telegram Bot**: Only accepts valid, unused keys from the server
3. **Firestore**: Properly audited with all connections logged
4. **Security**: No mock data, all connections authenticated
5. **Uniqueness**: Each email address gets exactly one permanent key

## Testing Commands

### Test Profile Page
```bash
# 1. Open profile page in browser
# 2. Verify key is displayed (format: TG-XXXXXXX-XXXXXX)
# 3. Copy key to clipboard
# 4. Verify connection status shows "Not Connected"
```

### Test Telegram Bot
```bash
# 1. Open @kitakita_receipt_bot in Telegram
# 2. Send: /start
# 3. Send: /connect TG-YOUR-KEY-HERE
# 4. Verify bot confirms successful connection
# 5. Check profile page shows "Connected" status
```

### Test Key Regeneration
```bash
# 1. Click "Refresh Key" in profile
# 2. Verify new key is generated
# 3. Old key should be invalidated
# 4. Test old key in bot (should fail)
# 5. Test new key in bot (should work)
```

This comprehensive test plan ensures the Telegram integration is no longer a mock system but a fully functional, secure, and auditable connection system. 